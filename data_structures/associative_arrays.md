# Table of Contents

1. [Associative Arrays / Maps / Dictionaries](#associative-arrays--maps--dictionaries)
2. [Implementation of Associative Arrays](#implementation-of-associative-arrays)
   - [Hashing](#hashing)
     - [Hash Function](#hash-function)
     - [Collision Handling](#collision-handling)
     - [Efficiency](#efficiency)
   - [Balanced Trees](#balanced-trees)
2. [Hash Set](#hash-set)

# Associative Arrays / Maps / Dictionaries

- Data structures that store key-value pairs and allow for efficient retrieval of values based on their associated keys

# Implementation of Associative Arrays

## Hashing

- Hash tables are a common implementation of associative arrays that use a hash function to map keys to indices in an array.
- Indexing: The value associated with the key is stored at the array index generated by the hash function.
- Hash tables are widely used in scenarios where fast access and unordered key storage are sufficient, such as caches, database indexing, and sets.
- Pros: Generally faster average-case performance _O(1)_ for insertions, deletions, and lookups.
- Cons
  - Worst-case performance can degrade to _O(n)_ if many collisions occur or if the hash function is poor.
  - Do not maintain any order of keys.

### Hash Function

- A hash function takes a key and converts it into an integer (the hash code). This integer is then mapped to an index in an array.

- The hash function for a hash table is a crucial component that determines how keys are mapped to indices in the table.
- A good hash function minimizes collisions (where multiple keys hash to the same index) and distributes keys uniformly across the table.
- The choice and design of a hash function depend on the specific requirements and characteristics of the data.
- A well-designed hash function will ensure efficient performance of the hash table by minimizing collisions and evenly distributing keys across the table.

- Hereâ€™s how a hash function is generally determined:
  - Characteristics of a Good Hash Function
    - Deterministic: For the same input key, the hash function should always produce the same output.
    - Uniform Distribution: It should distribute keys uniformly across the hash table to minimize collisions.
    - Efficient to Compute: It should be computationally efficient to calculate the hash value.
    - Minimize Collisions: It should minimize the likelihood of different keys producing the same hash value.

### Collision Handling

- Chaining
  - Chaining involves creating a linked list (or another data structure, such as a dynamic array) at each index of the hash table to store all elements that hash to the same index.
  - How Chaining Works:
    - Hashing: Compute the hash value for the key to find the index.
    - Collision Handling: If another key is already present at that index, the new key-value pair is added to the linked list at that index.
  - Advantages:
    - Flexibility: Easy to implement and can handle an unlimited number of collisions at each index.
    - Simplicity: Each index of the hash table simply points to a linked list of entries.
  - Disadvantages:
    - Extra Memory: Requires additional memory to store the pointers for the linked lists.
    - Performance: Can degrade to O(n) in the worst case (when all elements hash to the same index).

<br/>

- Open Addressing
  - Open addressing handles collisions by finding another open slot within the hash table.
  - When a collision occurs, the algorithm probes the table in a sequence to find an empty slot.
  - Types of Probing:
    - Linear Probing:
      - If a collision occurs at index _i_, check the next index _(i + 1) % table_size_, then _(i + 2) % table_size_, and so on.
      - This causes primary clustering, where a block of consecutive filled slots forms, making future insertions and searches within this block slower.
    - Quadratic Probing:
      - If a collision occurs at index _i_, check the indices _(i + 1^2) % table_size_, _(i + 2^2) % table_size_, and so on.
      - While quadratic probing reduces primary clustering by spreading out the probe sequence, it can still suffer from secondary clustering.
      - This happens when different keys that hash to the same initial index generate the same probe sequence.
      - Can be complex to ensure that the probing sequence covers all slots in the hash table, especially if the table size is not carefully chosen.
      - Offers a compromise between simple linear probing and more complex methods like double hashing.
      - Addresses primary clustering but requires careful consideration of table size and probe sequence to minimize secondary clustering.
    - Double Hashing:
      - Use a secondary hash function to calculate the step size.
      - If a collision occurs at index _i_, the next index is computed as _(i + j * h2(key)) % table_size_, where _h2_ is a secondary hash function and _j_ is the probe number.
      - This reduces clustering significantly and provides better distribution.
  - Clustering
    - Primary Clustering
      - This occurs in linear probing when a collision leads to a sequence of filled slots forming a contiguous block.
      - Subsequent insertions that hash to this block will require multiple probes to find an empty slot, exacerbating the problem.
    - Secondary Clustering
      - This occurs when different keys that hash to the same initial index follow the same probe sequence.
      - Even though they don't form a contiguous block, they end up clustered in the same pattern within the table.
  - Advantages:
    - Memory Efficient: No need for additional memory to store linked lists.
    - Performance: Can offer good performance with a well-designed hash function and probe sequence.
  - Disadvantages:
    - Clustering: Linear and quadratic probing can lead to clustering, where groups of filled slots form, degrading performance.
    - Table Size Dependency: The performance and behavior of open addressing depend heavily on the hash table's load factor (ratio of elements to table size). High load factors can significantly degrade performance.

### Efficiency

- When the hash function distributes keys uniformly across the array, and the load factor (ratio of entries to the array size) is kept low, hash tables provide average-case _O(1)_ time complexity for insertions, deletions, and lookups.

## Balanced Trees

- Balanced trees such as Red-Black trees or AVL trees can also be used to implement associative arrays.

- Tree Structure: Keys are stored in nodes of a balanced tree, which maintains a sorted order of keys.

- Balancing: After every insertion or deletion, the tree is rebalanced to ensure that the height of the tree remains logarithmic relative to the number of nodes.

- Search: The balanced tree structure allows for binary search, leading to O(log n) time complexity for insertions, deletions, and lookups.

- Order Preservation: Unlike hash tables, balanced trees maintain the keys in sorted order, which can be beneficial for range queries and ordered traversals.

- Pros: Provide consistent O(log n) performance for all operations, regardless of input. Maintain keys in sorted order, allowing for efficient range queries.

- Cons: Typically slower than hash tables in average-case performance due to the overhead of maintaining balance.

- Balanced Trees are used when ordered key storage is necessary, such as in databases (e.g., B-trees and B+ trees in relational databases) and in-memory data structures that require efficient range queries.

# Hash Set

- How Sets are Implemented Internally
  - Hash Table Structure: Similar to dictionaries, sets use a hash table to store elements. Each element in a set is hashed to determine its position in the table.
  - No Key-Value Pairs: Unlike dictionaries, which store key-value pairs, sets store only keys (the elements themselves). The values are not needed in sets, so they are essentially using the keys of a hash table to represent the set elements.
  - Efficient Operations: Sets provide efficient _O(1)_ average time complexity for operations like membership testing, insertion, and deletion, due to the hash table implementation.

- Key Points
  - Hash Function: Both sets and dictionaries use a hash function to determine where to store elements.
  - Collision Handling: Both handle collisions in similar ways, such as using open addressing with probing.
  - Efficiency: Both provide average-case _O(1)_ time complexity for key operations due to their hash table implementations.

- What does it mean for a hash set to use a hash table as its underlying data structure?

- What does it mean for a hash set to employ a hash function to map elements to buckets (slots) in the hash table, where each bucket contains only one element (or a reference to the element)?

- Elements in a hash set are not stored in any particular order; their placement is determined by the hash function and the hash table's implementation. Explain.
